# 📁 동적 & 정적 할당

이번 포스팅에서는 동적과 정적에 대해서 작성해보려고 합니다.

## 🤔 정적/동적 구분 기준

소스 코드를 돌릴 때 통합개발환경은 컴파일과 실행을 거친다.  
컴파일 과정에서 우리가 짠 소스 코드가 제대로 되었는지 살펴보고  
이상이 없으면 실행 단계로 넘어간다. 여기서도 오류가 없으면 콘솔 창에 실행  
결과를 출력해준다.

정적(Static), 동적(Dynamic) 할당을 구분하는 기준은 '프로그램 실행 중에  
메모리 공간을 할당하는가?' 이다. **정적 할당**은 컴파일 단계에서 필요한 메모리  
공간을 할당하고, **동적 할당**은 실행 단계에서 공간을 할당해주는 것이다.

## 📄 메로리 영역

지금까지는 메모리를 그냥 몽뚱그려 '변수를 저장하는 공간. 방 하나하나마다 주소가 있다'  
정도로 다루었다. 하지만 메모리는 그 활용과 기능에 따라 크게 4가지 종류로 구분된다.

Code/Data/Stack/Heap

### ⇲ Code 영역은?

-> 함수, 상수 저장

함수와 상수, 실행한 프로그램의 코드가 저장되는 공간이다.  
함수나 상수는 컴파일 단계에서 검사를 마치고 저장되므로 이 곳은 정적 메모리이다.

### ⇲ Data 영역은?

-> 전역/정적 변수 저장

전역 변수와 정적(Static) 변수가 저장되는 영역이다.  
Code 영역과 마찬가지로 컴파일 단계에서 검사를 끝마치고 메모리 할당이 이루어진다.

추가적으로 C,C++에서 전역 변수와 정적 변수를 선언하게 되면 따로 초기화하지 않아도 0으로  
자동 초기화 되어 있다는 사실을 발견할 수 있다. 이는 Stack 영역에 저장되는 지역 변수나 매개 변수와 달리 전역 변수와 정적 변수는 Data 영역에 저장되기 때문이다.

### ⇲ Stack 영역은

-> 지역/매개 변수 저장

지역 변수와 매개변수가 저장되는 곳이다. 즉 통상적으로 우리가 변수라고 부르는 것들을  
선언하면 이 영역에서 공간을 할당해준다.

**🤔 왜 동적 메모리일까?**
지역 변수와 매개 변수는 선언된 함수 내에서만 사용 가능하다.  
그 함수를 벗어나면 할당된 공간을 반납하고 사라져야 한다.  
프로그램 실행 과정에서 이런 일은 함수 하나가 사라질 때마다 빈번하게 일어난다.  
가장 활발하게 공간이 차고 비워지는 곳인 셈이다.

### ⇲ Heap 영역은

동적 할당을 받아오는 장소다. 동적 할당 받은 공간은 우리가 별도의 명령어(C라면 free(), C++이라면 Delete())를 이용해 해제해주기 전까지는 사라지지 않는다.  
동적 할당은 프로그램 실행 중에 발생하므로 Heap은 동적 메모리이다.

## ✨ 정적 메모리 할당

메모리의 영역에 대해서 정리하느라 이야기가 길어졌는데 이제 정적 할당에 대해서 정리해보려고 한다  
정적 할당은 아까 위에서도 작성했지만 컴파일 단계에서 메모리 공간을 할당받는 것이다.  
대표적인 예시로는 변수나 배열을 선언하는 것을 들 수 있다.  
한 번 컴파일을 시작하면 그때부터는 두 이상 추가적으로 배열을 선언할 수 없다.

### 💻 소스 코드

```c
int i, j;
int buffer [100];
char name[] = "data structure";
```

## ✨ 동적 메모리 할당

프로그램 실행 도중에 동적으로 메모리를 할당하며 컴파일 할 때 미리 정해지는 것이 아닌  
실행 단계에서 공간이 정해지는 기능을 가지고 있으며 매우 효율적이다.

컴파일 할 때 미리 안정해진다는 효율적이라는 장점을 가지고 있으나 소스코드가 매우 복잡하다는 단점을 가지고 있다.

### 💻 소스 코드

```c
#include <stdlib.h> //동적 메모리 관련 함수 불러오기

...
int *ptr = NULL;
int size = 100;

ptr = (int*) malloc (sizeof(int)*size); // malloc() 메모리 할당
...

free ( ptr ); // 메모리 해제
```

## ⌨️ 함수

### ⇲ malloc() 함수

`#include <stdlib.h>` 헤더 안에 있는 함수이며 malloc 함수는 바이트 단위로 메모리를 할당합니다.  
메모리 블럭의 첫 번째 바이트에 대한 주소를 반환하는데, 요청 값이 없으면 NULL을 반환합니다.

**int형 데이터 저장을 위한 메모리 공간을 위해서는**

```c
int *p;
p = (int*) malloc(sizeof(int));
```

**char형 데이터 저장을 위한 메모리 공간을 위해서는**

```c
char *p;
p = (char*) malloc( sizeof(char));
```

### ⇲ free() 함수

```c
void free(void *ptr);
```

위와 같은 형태로 ptr에 할당되었던 메모리 블록을 시스템에 반납한다.  
반납할때는 value를 써줘야하기 때문에 \*를 붙인다.

실제로는 다음과 같이 사용된다.

```c
int *p;
p = (int*) malloc(sizeof(int));
free(p);
```

## ✨ 포인터를 이용한 메모리 할당

이렇듯 동적 메모리 할당은 **'포인터'**로 이루어진다.  
포인터가 값이 할당된 주소를 가리키니 포인터를 활용하는 것은 당연하며 동적 메모리가 사용되고 다시 반납되는 과정을 보도록 하자

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
int *pi = NULL; char *pc = NULL;

    pi = (int *) malloc ( sizeof(int) ); // 동적 메모리 할당
    if ( pi == NULL ) { printf("동적 메모리 할당 오류\n"); exit(1); }
      *pi = 100; // 동적 메모리 사용
      printf("%d\n", *pi);
    free(pi); // 동적 메모리 반납

    pc = (char *) malloc ( sizeof(char) ); // 동적 메모리 할당
    if ( pc == NULL ) { printf("동적 메모리 할당 오류\n" ); exit(1); }
      *pc = 'm'; // 동적 메모리 사용
      printf("%c\n", *pc);
    free(pc); // 동적 메모리 반납

  return 0;
}
```

실제 값을 지정하지 않고 *pi, *pc만을 가정한다. malloc함수로 동적 메모리를 할당하고 실제로 사용한다.

그리고 마지막으로 free함수로 동적 메모리를 반납한다!!

포인터로 배열을 지목하는 방법도 어렵지 않다.

```c
#include <stdio.h>
#include <malloc.h>
int main(void) {
    int i, size=5;
    int *arr;

    arr = (int*) malloc ( sizeof(int) * size );

    for ( i=0; i<size; i++ ) {
        arr[i] = i;
    }
    for ( i=0; i<size; i++ ) {
    	printf("%d\n", *(arr+i));
    }
    free (arr);
    return 0;
}
```

### 그 외의 동적 메모리 함수들

#### calloc()

`void *calloc(size_t n, size_t size);`
0으로 초기화된 메모리를 할당하는 함수다.

#### realloc()

`void *realloc(void *memblock, size_t size);`
할당하였던 메모리 블록의 크기를 변경하는 것이다.  
malloc에서 지정해줬던 사이즈를 다시 키우거나 줄이는 작업이 필요할 때 쓴다.

```c
int *p;
p = (int*) malloc (5 * sizeof(int));
p = (int*) realloc (p, 7 * sizeof(int));
```
